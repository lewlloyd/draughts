#BlueJ class context
comment0.params=frame
comment0.target=Board(javax.swing.JFrame)
comment0.text=\n\ Constructor\ for\ objects\ of\ class\ Board\n\ @param\ JFrame\ the\ frame\ created\ in\ the\ Game\ class,\ passed\ here\ to\ have\ a\ board\ added\ to\ it\n
comment1.params=
comment1.target=void\ getStartState()
comment1.text=\n\ Initialise\ the\ game's\ currentState,\ with\ the\ board\ represented\ by\ an\ 8x8\ 2D\ array\ of\ integers.\ \n\ 1's\ indicate\ that\ a\ black\ piece\ is\ occupying\ the\ corresponding\ square,\ and\ 2's\ represent\ white\ pieces.\ \n\ A\ position\ with\ a\ 0\ value\ is\ unoccupied.\n
comment10.params=player\ state\ i\ j\ i1\ j1
comment10.target=boolean\ stepPoss(int,\ int[][],\ int,\ int,\ int,\ int)
comment10.text=\n\ Method\ to\ see\ whether\ a\ step\ is\ possible\ from\ one\ given\ position\ to\ another.\n\ @param\ int\ player\ the\ player\ who\ would\ be\ making\ the\ step\n\ @param\ int[][]\ state\ the\ game\ state\ the\ step\ would\ be\ made\ from\n\ @param\ int\ i\ the\ row\ the\ piece\ is\ stepping\ from\n\ @param\ int\ j\ the\ column\ the\ piece\ is\ stepping\ from\n\ @param\ int\ i1\ the\ row\ the\ piece\ is\ moving\ to\n\ @param\ int\ j1\ the\ column\ the\ piece\ is\ moving\ to\n\ @return\ boolean\ whether\ or\ not\ the\ step\ is\ possible\n
comment11.params=state\ player\ i\ j\ i1\ j1\ i2\ j2
comment11.target=int[][]\ makeJump(int[][],\ int,\ int,\ int,\ int,\ int,\ int,\ int)
comment11.text=\n\ Method\ to\ make\ a\ jump,\ then\ return\ the\ resulting\ state\ as\ a\ new\ state.\n\ @param\ int[][]\ state\ the\ game\ state\ the\ jump\ is\ happening\ from\n\ @param\ int\ player\ the\ player\ making\ the\ jump\n\ @param\ int\ i\ the\ row\ the\ piece\ is\ jumping\ from\n\ @param\ int\ j\ the\ column\ the\ piece\ is\ jumping\ from\n\ @param\ int\ i1\ the\ row\ the\ piece\ is\ jumping\ over\n\ @param\ int\ j1\ the\ column\ the\ piece\ is\ jumping\ over\n\ @param\ int\ i2\ the\ row\ the\ piece\ is\ jumping\ to\n\ @param\ int\ j2\ the\ column\ the\ piece\ is\ jumping\ to\n\ @return\ int[][]\ the\ resulting\ state\n
comment12.params=state\ player\ i\ j\ i1\ j1
comment12.target=int[][]\ makeStep(int[][],\ int,\ int,\ int,\ int,\ int)
comment12.text=\n\ Method\ to\ make\ a\ step,\ then\ return\ the\ resulting\ state\ as\ a\ new\ state\n\ @param\ int[][]\ state\ the\ game\ state\ the\ step\ is\ being\ made\ from\n\ @param\ int\ player\ the\ player\ making\ the\ step\n\ @param\ int\ i\ the\ row\ the\ piece\ is\ stepping\ from\n\ @param\ int\ j\ the\ column\ the\ piece\ is\ stepping\ from\n\ @param\ int\ i1\ the\ row\ the\ piece\ is\ moving\ to\n\ @param\ int\ j1\ the\ column\ the\ piece\ is\ moving\ to\n\ @return\ int[][]\ the\ resulting\ state\n
comment13.params=state
comment13.target=int[][]\ cloneState(int[][])
comment13.text=\n\ A\ method\ to\ clone\ a\ given\ state.\n\ @param\ int[][]\ the\ state\ to\ be\ cloned\n\ @return\ int[][]\ the\ clone\n
comment14.params=player
comment14.target=int\ setKing(int)
comment14.text=\n\ A\ method\ to\ return\ the\ appropriate\ number\ representing\ a\ king\ piece\ for\ a\ given\ player.\n\ @param\ int\ player\ the\ player\ in\ question\n\ @return\ int\ the\ number\ representing\ a\ king\ piece\n
comment15.params=player\ x
comment15.target=boolean\ kingCheck(int,\ int)
comment15.text=\n\ Checking\ for\ when\ a\ piece\ reaches\ the\ end\ of\ the\ board\ and\ needs\ to\ be\ come\ a\ king.\n\ @param\ int\ player\ the\ player\ who's\ piece\ it\ is\n\ @param\ x\ the\ row\ on\ the\ board\ the\ piece\ has\ reached\n\ @return\ boolean\ whether\ or\ not\ the\ piece\ is\ now\ a\ king\n
comment16.params=state
comment16.target=boolean\ wWins(int[][])
comment16.text=\n\ Checking\ to\ see\ if\ the\ user\ has\ won\ the\ game\ in\ a\ given\ state.\n\ @param\ int[][]\ the\ state\ we\ want\ to\ check\ for\n\ @return\ boolean\ whether\ or\ not\ the\ user\ wins\ in\ this\ state\n
comment17.params=state
comment17.target=boolean\ bWins(int[][])
comment17.text=\n\ Checking\ to\ see\ if\ the\ computer\ has\ won\ the\ game\ in\ a\ given\ state.\n\ @param\ int[][]\ the\ state\ we\ want\ to\ check\ for\n\ @return\ boolean\ whether\ or\ not\ the\ computer\ wins\ in\ this\ state\n
comment18.params=state\ depth\ player\ alpha\ beta
comment18.target=int\ minimax(int[][],\ int,\ int,\ int,\ int)
comment18.text=\n\ The\ minimax\ algorithm\ that\ is\ called\ by\ getAIMove\ that\ calls\ itself\ recursively\ to\ get\ a\ value\ for\ each\ possible\ next\ state.\ \n\ Goes\ to\ a\ depth\ specified\ by\ a\ limit\ set\ by\ the\ difficulty\ level\ (see\ setLimit()\ below),\ passing\ a\ value\ up\ the\ tree\ when\ that\ depth\ is\ reached,\n\ when\ a\ state\ is\ reached\ in\ which\ one\ of\ the\ players\ wins,\ or\ when\ a\ state\ is\ reached\ in\ which\ the\ player\ cannot\ make\ any\ more\ moves.\n\ @param\ int[][]\ state\ the\ state\ from\ which\ it\ is\ being\ called\n\ @param\ int\ depth\ how\ far\ it\ is\ going\ down\ the\ search\ tree\n\ @param\ int\ player\ the\ player\ who\ is\ making\ the\ next\ (imaginary)\ move\n\ @param\ int\ alpha\ the\ value\ of\ alpha\ at\ the\ previous\ state\n\ @param\ int\ beta\ the\ value\ of\ beta\ at\ the\ previous\ state\n\ @return\ int\ a\ value\ corresponding\ to\ the\ result\ reached\n
comment19.params=state
comment19.target=int\ evaluateState(int[][])
comment19.text=\n\ A\ method\ to\ return\ a\ value\ for\ the\ state\ reached\ when\ the\ depth\ limit\ has\ been\ hit\ in\ minimax.\ This\ operates\ as\ a\ heuristic,\ with\ the\ value\ calculated\n\ by\ subtracting\ the\ number\ of\ white\ pieces\ from\ the\ number\ of\ black\ pieces,\ then\ adding\ the\ number\ of\ black\ kings\ (multiplied\ by\ 2,\ to\ give\ kings\ more\n\ weight),\ and\ subtracting\ the\ number\ of\ white\ kings\ (multiplied\ by\ 2,\ again).\ In\ the\ minimax\ algorithm,\ the\ player\ who\ represents\ "MAX"\ (player\ 1\ /\ the\n\ computer)\ wants\ this\ to\ be\ a\ high\ score,\ and\ "MIN"\ (player\ 2\ /\ the\ user)\ wants\ it\ to\ be\ low.\n\ @param\ int[][]\ the\ state\ reached\n\ @return\ int\ the\ value\ given\n
comment2.params=frame
comment2.target=void\ makeBoardRep(javax.swing.JFrame)
comment2.text=\n\ Create\ the\ JPanel\ for\ the\ board\ representation\ and\ its\ contents,\ including\ all\ of\ the\ squares\n\ as\ Objects\ of\ the\ Class\ Square\ (which\ extends\ JButton).\n\ @param\ JFrame\ the\ frame\ created\ in\ the\ Game\ class\ that\ we\ want\ to\ add\ the\ board\ display\ to\n
comment20.params=
comment20.target=int[][]\ getBestState()
comment20.text=\n\ Searches\ through\ our\ ArrayList\ of\ successorEvaluations\ and\ returns\ the\ best\ next\ state\ given\ the\ current\ state.\n\ @return\ int[][]\ the\ best\ next\ state\n
comment21.params=difficulty
comment21.target=void\ setLimit(int)
comment21.text=\n\ Set\ a\ limit\ on\ the\ number\ of\ static\ evaluations\ the\ minimax\ algorithm\ can\ make,\ based\ on\ the\ difficulty\n\ level\ selected\ by\ the\ user\ before\ starting\ the\ game.\n\ @param\ int\ the\ difficulty\ level\ selected.\n
comment3.params=
comment3.target=void\ placePieces()
comment3.text=\n\ Match\ the\ currentState\ of\ the\ game\ (which\ positions\ are\ occupied\ by\ which\ pieces),\ with\ what\ is\ \n\ displayed\ on\ the\ graphical\ board,\ making\ sure\ pieces\ are\ visible\ where\ they\ should\ be.\n
comment4.params=square
comment4.target=void\ moveRequest(Square)
comment4.text=\n\ When\ a\ square\ has\ been\ clicked\ on\ by\ the\ user,\ come\ here\ to\ work\ out\ what\ move\ is\ being\ requested,\n\ and,\ if\ the\ move\ is\ valid,\ to\ make\ it\ happen.\n\ @param\ Square\ the\ square\ that\ has\ been\ clicked\ on\n
comment5.params=
comment5.target=void\ getAIMove()
comment5.text=\n\ Called\ from\ the\ play()\ method\ of\ the\ Game\ class,\ a\ method\ to\ get\ the\ computer's\ next\ move\ and\ update\n\ the\ board\ accordingly.\n
comment6.params=state\ player
comment6.target=getPossibleStates(int[][],\ int)
comment6.text=\n\ A\ method\ to\ get\ the\ possible\ next\ states\ for\ either\ player\ -\ although\ this\ only\ applies\ to\ player\ 2\n\ (the\ user)\ for\ the\ purposes\ of\ the\ minimax\ evaluation.\n\ @param\ int[][]\ the\ state\ you\ want\ to\ get\ the\ next\ states\ for\n\ @param\ int\ the\ player\ in\ question\n\ @return\ ArrayList<int[][]>\ an\ ArrayList\ of\ the\ possible\ next\ states\n
comment7.params=player\ state\ i\ j\ i1\ j1\ i2\ j2
comment7.target=boolean\ jumpPoss(int,\ int[][],\ int,\ int,\ int,\ int,\ int,\ int)
comment7.text=\n\ Method\ to\ see\ whether\ a\ jump\ is\ possible\ from\ one\ given\ position\ to\ another.\n\ @param\ int\ player\ the\ player\ who\ would\ be\ making\ the\ jump\n\ @param\ int[][]\ state\ the\ game\ state\ the\ jump\ would\ be\ made\ from\n\ @param\ int\ i\ the\ row\ the\ piece\ is\ jumping\ from\n\ @param\ int\ j\ the\ column\ the\ piece\ is\ jumping\ from\n\ @param\ int\ i1\ the\ row\ the\ piece\ is\ jumping\ over\n\ @param\ int\ j1\ the\ column\ the\ piece\ is\ jumping\ over\n\ @param\ int\ i2\ the\ row\ the\ piece\ is\ jumping\ to\n\ @param\ int\ j2\ the\ column\ the\ piece\ is\ jumping\ to\n\ @return\ boolean\ whether\ or\ not\ the\ jump\ is\ possible\n
comment8.params=player\ state
comment8.target=boolean\ takesPossState(int,\ int[][])
comment8.text=\n\ A\ method\ to\ determine\ whether\ a\ given\ player\ can\ make\ a\ take\ from\ the\ current\ game\ state.\n\ @param\ int\ player\ the\ player\ in\ question\n\ @param\ int[][]\ state\ the\ state\ in\ question\n\ @return\ boolean\ whether\ or\ not\ a\ take\ is\ possible\n
comment9.params=player\ state\ i\ j
comment9.target=boolean\ takesPossPosition(int,\ int[][],\ int,\ int)
comment9.text=\n\ A\ method\ to\ determine\ whether\ a\ given\ player\ can\ make\ a\ take\ with\ a\ piece\ in\ a\ given\ position.\n\ @param\ int\ player\ the\ player\ in\ question\n\ @param\ int[][]\ state\ the\ state\ in\ question\n\ @param\ int\ i\ the\ row\ the\ selected\ piece\ is\ in\n\ @param\ int\ j\ the\ column\ the\ selected\ piece\ is\ in\n\ @return\ boolean\ whether\ or\ not\ a\ take\ is\ possible\n
numComments=22
